import { NextResponse } from 'next/server'
import { createServerClient } from '@supabase/ssr'
import { cookies } from 'next/headers'
import crypto from 'crypto'
import { exec } from 'child_process'
import { writeFile, unlink } from 'fs/promises'
import { join } from 'path'
import os from 'os'
import { Database } from '@/types/supabase'

// Initialize server-side Supabase client
const createServerSupabaseClient = async () => {
  const cookieStore = await cookies()

  if (!process.env.NEXT_PUBLIC_SUPABASE_URL) {
    throw new Error('Missing NEXT_PUBLIC_SUPABASE_URL')
  }

  if (!process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY) {
    throw new Error('Missing NEXT_PUBLIC_SUPABASE_ANON_KEY')
  }

  return createServerClient<Database>(
    process.env.NEXT_PUBLIC_SUPABASE_URL,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value
        },
        set(name: string, value: string, options: any) {
          try {
            cookieStore.set({ name, value, ...options })
          } catch (error) {
            console.error('Error setting cookie:', error)
          }
        },
        remove(name: string, options: any) {
          try {
            cookieStore.delete({ name, ...options })
          } catch (error) {
            console.error('Error removing cookie:', error)
          }
        },
      },
    }
  )
}

// Function to run ClamAV scan
const scanWithClamAV = async (filePath: string): Promise<{ isClean: boolean; threats: string[] }> => {
  return new Promise((resolve, reject) => {
    exec(`clamscan --infected --no-summary ${filePath}`, (error, stdout, stderr) => {
      if (error) {
        // ClamAV returns error code 1 when it finds a virus
        if (error.code === 1) {
          const threats = stdout.split('\n')
            .filter(line => line.includes('FOUND'))
            .map(line => {
              const foundIndex = line.indexOf('FOUND')
              return foundIndex > -1 ? line.slice(0, foundIndex).trim() : 'Unknown threat'
            })
          resolve({ isClean: false, threats })
        } else {
          // Real error occurred
          console.error('ClamAV error:', stderr)
          reject(new Error('Scan failed'))
        }
      } else {
        // No virus found
        resolve({ isClean: true, threats: [] })
      }
    })
  })
}

export async function POST(req: Request) {
  try {
    const supabase = await createServerSupabaseClient()
    
    // Get current user session
    const { data: { session } } = await supabase.auth.getSession()
    if (!session) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const formData = await req.formData()
    const file = formData.get('file')
    
    if (!file || !(file instanceof File)) {
      return NextResponse.json(
        { error: 'No valid file provided' },
        { status: 400 }
      )
    }

    // Generate a unique file name
    const fileName = `${crypto.randomUUID()}-${file.name}`
    const fileBuffer = await file.arrayBuffer()
    const fileContent = new Uint8Array(fileBuffer)

    // Create scan record
    const { data: scanRecord, error: insertError } = await supabase
      .from('scan_results')
      .insert({
        user_id: session.user.id,
        file_name: file.name,
        file_type: file.type,
        file_size: file.size,
        scan_status: 'scanning',
        threats_found: [],
        is_clean: false
      })
      .select()
      .single()

    if (insertError || !scanRecord) {
      console.error('Error creating scan record:', insertError)
      return NextResponse.json(
        { error: 'Failed to create scan record' },
        { status: 500 }
      )
    }

    // Create temporary file for scanning
    const tempPath = join(os.tmpdir(), fileName)
    await writeFile(tempPath, fileContent)

    try {
      // Scan the file
      const startTime = Date.now()
      const { isClean, threats } = await scanWithClamAV(tempPath)
      const scanTime = Date.now() - startTime

      // Update scan record
      const { error: updateError } = await supabase
        .from('scan_results')
        .update({
          scan_status: 'completed',
          threats_found: threats,
          scan_time: scanTime,
          is_clean: isClean
        })
        .eq('id', scanRecord.id)

      if (updateError) {
        console.error('Error updating scan record:', updateError)
        return NextResponse.json(
          { error: 'Failed to update scan record' },
          { status: 500 }
        )
      }

      // Upload to Supabase storage if clean
      if (isClean) {
        const { data: uploadData, error: uploadError } = await supabase
          .storage
          .from('malware-scans')
          .upload(`${session.user.id}/${fileName}`, fileContent)

        if (uploadError) {
          console.error('Error uploading file:', uploadError)
          return NextResponse.json(
            { error: 'Failed to upload file' },
            { status: 500 }
          )
        }

        // Update scan record with file URL
        const fileUrl = supabase
          .storage
          .from('malware-scans')
          .getPublicUrl(`${session.user.id}/${fileName}`)

        await supabase
          .from('scan_results')
          .update({
            file_url: fileUrl.data.publicUrl
          })
          .eq('id', scanRecord.id)
      }

      return NextResponse.json({
        success: true,
        isClean,
        threats,
        scanTime,
        scanId: scanRecord.id,
        fileUrl: isClean ? supabase
          .storage
          .from('malware-scans')
          .getPublicUrl(`${session.user.id}/${fileName}`)
          .data.publicUrl : null
      })
    } catch (error) {
      console.error('Scan error:', error)

      // Update scan record with error status
      await supabase
        .from('scan_results')
        .update({
          scan_status: 'failed',
          error_message: error instanceof Error ? error.message : 'Unknown error'
        })
        .eq('id', scanRecord.id)

      return NextResponse.json(
        { error: 'Scan failed' },
        { status: 500 }
      )
    } finally {
      // Clean up temporary file
      try {
        await unlink(tempPath)
      } catch (error) {
        console.error('Error deleting temp file:', error)
      }
    }
  } catch (error) {
    console.error('Request error:', error)
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    )
  }
}


